// rfc_gdb.cpp
// Programa educativo para calcular un RFC básico y una homoclave aproximada.
// Compilar con: g++ -g rfc_gdb.cpp -o rfc_gdb

#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
#include <map>

// Eliminar tildes y normalizar Ñ -> N (simple)
std::string normalizar(const std::string &s) {
    std::string out;
    out.reserve(s.size());
    // Mapa simple para vocales acentuadas (minúsculas y mayúsculas)
    static const std::map<char,char> remap = {
        {(char)'\xC1','A'}, // Á (latin1) — en entornos utf8 esto puede no mapear; usamos sustitución sencilla abajo
    };
    for (unsigned char c : s) {
        // Si es letra ascii con acento común en UTF-8, aquí no se decodifica.
        // Hacemos tratamiento simple: convertir a mayúscula y sustituir Ñ por N.
        char cc = c;
        // convertir a mayúscula en C locale
        cc = std::toupper((unsigned char)cc);
        if (cc == 'Ñ') cc = 'N';
        // sustituir caracteres no alfabéticos por espacio
        out.push_back(cc);
    }
    return out;
}

// Buscar la primera vocal interna (A,E,I,O,U) en una cadena (desde pos 1)
char primeraVocalInterna(const std::string &s) {
    for (size_t i = 1; i < s.size(); ++i) {
        char c = s[i];
        if (c=='A' || c=='E' || c=='I' || c=='O' || c=='U') return c;
    }
    return 'X';
}

// Generar homoclave aproximada (educativa):
// simple: suma de códigos de los caracteres mod 100 -> dos dígitos + una letra (A-Z) derivada
std::string homoclaveAproximada(const std::string &base) {
    int sum = 0;
    for (unsigned char c : base) sum += c;
    int num = sum % 100; // dos dígitos
    char letra = 'A' + (sum % 26);
    char buf[4];
    std::snprintf(buf, sizeof(buf), "%02d%c", num, letra);
    return std::string(buf);
}

std::string calcularRFC(const std::string &nombre, const std::string &apellidoP, const std::string &apellidoM, const std::string &fecha) {
    // Normalizar y forzar mayúsculas (simplificado)
    std::string N = nombre;
    std::string P = apellidoP;
    std::string M = apellidoM;

    // convertir a mayúsculas usando locale C
    std::transform(N.begin(), N.end(), N.begin(), [](unsigned char c){ return std::toupper(c); });
    std::transform(P.begin(), P.end(), P.begin(), [](unsigned char c){ return std::toupper(c); });
    std::transform(M.begin(), M.end(), M.begin(), [](unsigned char c){ return std::toupper(c); });

    // manejar casos vacíos
    if (P.empty()) P = "X";
    // Buscar primera vocal interna en apellido paterno
    char v = primeraVocalInterna(P);
    // Primera letra apellido materno:
    char m0 = (M.empty() ? 'X' : M[0]);
    // Primera letra del nombre
    char n0 = (N.empty() ? 'X' : N[0]);

    // Construir las primeras 4 letras
    std::string base;
    base.push_back(P[0]);
    base.push_back(v);
    base.push_back(m0);
    base.push_back(n0);

    // Fecha en formato YYYY-MM-DD esperado
    // extraer YYMMDD
    std::string yy = "00", mm = "00", dd = "00";
    if (fecha.size() >= 10 && fecha[4]=='-' && fecha[7]=='-') {
        yy = fecha.substr(2,2);
        mm = fecha.substr(5,2);
        dd = fecha.substr(8,2);
    } else {
        // si no está en formato esperado, intentamos usar partes simples
        // (para depuración)
    }

    std::string rfc = base + yy + mm + dd;
    // calcular homoclave aproximada
    std::string hc = homoclaveAproximada(base + yy + mm + dd);
    return rfc + hc;
}

int main() {
    std::string nombre, apellidoP, apellidoM, fecha;
    std::cout << "Introduce tu nombre(s): ";
    std::getline(std::cin, nombre);
    std::cout << "Introduce apellido paterno: ";
    std::getline(std::cin, apellidoP);
    std::cout << "Introduce apellido materno (si no tienes, deja vacío y ENTER): ";
    std::getline(std::cin, apellidoM);
    std::cout << "Introduce fecha de nacimiento (YYYY-MM-DD): ";
    std::getline(std::cin, fecha);

    std::string resultado = calcularRFC(nombre, apellidoP, apellidoM, fecha);
    std::cout << "\nRFC (educativo, sin validez oficial): " << resultado << std::endl;
    std::cout << "(La homoclave es aproximada y para fines educativos solamente)\n";

    return 0;
}
